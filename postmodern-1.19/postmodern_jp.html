<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<title>Postmodern リファレンスマニュアル</title>
	<link rel="stylesheet" type="text/css" href="style_jp.css"/>
	<script type="text/javascript" src="./js/jquery-3.3.1.js"></script>
	<script type="text/javascript" src="./js/jquery.inview.js"></script>
	<script type="text/javascript" src="./js/decorateLispCode.js" charset="UTF-8"></script>
	<script type="text/javascript" src="./js/lispOperator.js" charset="UTF-8"></script>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>

<body>
<script language="javascript">
//<!--
var lisOpe = lisOpeCL.concat(lisOpeSSql, lisOpePostmodern);

$(function() {
	$('pre.code').one('inview', function(event, isInView, visiblePartX, visiblePartY) {
		decorateLispCode(this, lisOpe);
	});
});
// -->
</script>

<h1>Postmodern リファレンスマニュアル</h1>

<p>
　これは <code>postmodern</code> と名付けられたコンポーネントのリファレンスマニュアルで、同名<a href="index_jp.html">ライブラリ</a>の一部である。
</p>

<p>
　注意として、このパッケージは CL-postgres から <a href="cl-postgres_jp.html#database-connection"><span class="type">database-connection</span></a> 型と <a href="cl-postgres_jp.html#database-error"><span class="type">database-error</span></a> 型をエクスポートし、いくつかの演算子を <a href="s-sql_jp.html">S-SQL</a> からエクスポートする。
</p>

<p>
　論理的にデータベースとの通信が必要なマクロ <a href="#query"><code class="operator">query</code></a> 、マクロ <a href="#execute"><code class="operator">execute</code></a> 、その他の関数は、何らかの問題が発生した場合にコンディション <a href="cl-postgres_jp.html#conditions"><code class="type">database-error</code></a> を通知する。特殊なケースとして、接続を遮断するエラー（ソケットエラー、データベースシャットダウン）は <a href="cl-postgres_jp.html#database-connection-error"><code class="type">database-connection-error</code></a> の副型を発生させ、エラーとなった処理を再試行する再起動 <code class="keyword">:reconnect</code> を提供する。
</p>

<h2>目次</h2>

<ol>
<li><a href="#connecting">接続</a></li>
<li><a href="#querying">クエリ</a></li>
<li><a href="#inspect">データベースの検査</a></li>
<li><a href="#daos">データベースアクセスオブジェクト</a></li>
<li><a href="#tabledef">テーブル定義と作成</a></li>
<li><a href="#schemata">スキーマ</a></li>
<li><a href="#index">シンボル索引</a></li>
</ol>

<a name="connecting"></a>
<h2>接続</h2>

<a name="database-connection"></a>
<p class="def">
<span class="deftype">クラス</span>
<span class="type">database-connection</span>
</p>

<p class="desc">
　この型のオブジェクトはデータベース接続を示す。
</p>

<a name="connect"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">connect</span> <span class="parameter">(database user password host &amp;key (port 5432) pooled-p use-ssl)</span><br />
&#8594; database-connection
</p>

<p class="desc">
　指定された <code class="parameter">user</code> と <code class="parameter">database</code> で新しいデータベース接続を作成する。 port のデフォルトは、ほとんどの PostgreSQL サーバが使用している 5432 である。 <code class="parameter">pooled-p</code> が <code>T</code> 場合、接続プールから利用可能な接続を取得し、接続が切断された時プールに戻される。 <code class="parameter">use-ssl</code> は、関数 <a href="cl-postgres_jp.html#open-database"><code class="operator">open-database</code></a> への指定同様に、 <code class="keyword">:no</code> 、 <code class="keyword">:yes</code> 、または <code class="keyword">:try</code> を指定でき、デフォルトは <a href="#*default-use-ssl*"><code class="variable">*default-use-ssl*</code></a> の値である。
</p>

<a name="*default-use-ssl*"></a>
<p class="def">
<span class="deftype">変数</span>
<span class="variable">*default-use-ssl*</span>
</p>

<p class="desc">
　関数 <a href="#connect"><code class="operator">connect</code></a> の引数 <code class="parameter">use-ssl</code> のデフォルト値。ここに <code class="keyword">:no</code> を指定できる。それ以外に指定した場合、必ず <a href="http://common-lisp.net/project/cl-plus-ssl/">CL+SSL</a> ライブラリをロードする必要がある。
</p>

<a name="disconnect"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">disconnect</span> <span class="parameter">(database-connection)</span>
</p>

<p class="desc">
　通常のデータベース接続を切断するか、プールされた接続をプールに戻す。
</p>

<a name="connected-p"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">connected-p</span> <span class="parameter">(database-connection)</span><br />
&#8594; boolean
</p>

<p class="desc">
　指定された connection がまだサーバーに接続されているかどうかを示す真偽値を返す。
</p>

<a name="reconnect"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">reconnect</span> <span class="parameter">(database-connection)</span>
</p>

<p class="desc">
　切断されたデータベース接続を再接続する。プールされた接続には許されない。それらは接続が切断された後、他のプロセスによって使用されている可能性がある。
</p>

<a name="*database*"></a>
<p class="def">
<span class="deftype">変数</span>
<span class="variable">*database*</span>
</p>

<p class="desc">
　現在のデータベースを保持する特殊変数。データベース上で動作するほとんどの関数とマクロは、これが接続されたデータベースに束縛されていると想定している。
</p>

<a name="with-connection"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">with-connection</span> <span class="parameter">(spec &amp;body body)</span>
</p>

<p class="desc">
　<code class="parameter">spec</code> で指定された接続で <a href="#*database*"><code class="variable">*database*</code></a> を束縛し、 <code class="parameter">body</code> を評価する。 <code class="parameter">spec</code> は関数 <a href="#connect"><code class="operator">connect</code></a> に適用できるリストでなければならない。
</p>

<a name="call-with-connection"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">call-with-connection</span> <span class="parameter">(spec thunk)</span>
</p>

<p class="desc">
　マクロ <a href="#with-connection"><code class="operator">with-connection</code></a> のバックエンド機能。 <code class="parameter">spec</code> （関数 <a href="#connect"><code class="operator">connect</code></a> に適用できるリストでなければならない）で指定された新しい接続で <a href="#*database*"><code class="variable">*database*</code></a> を束縛し、その新しい環境で第 2 引数に与えられた引数不要の関数を実行する。関数から戻るあるいはスローすると、新しい接続は切断される。
</p>

<a name="connect-toplevel"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">connect-toplevel</span>  <span class="parameter">(database user password host &amp;key (port 5432))</span>
</p>

<p class="desc">
　<a href="#*database*"><code class="variable">*database*</code></a> を新しい接続に束縛する。1つの接続のみが必要な場合、または REPL からデバッグ用接続を求める場合に、これを使用する。
</p>

<a name="disconnect-toplevel"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">disconnect-toplevel</span> <span class="parameter">()</span>
</p>

<p class="desc">
　<a href="#*database*"><code class="variable">*database*</code></a> を切断する。
</p>

<a name="clear-connection-pool"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">clear-connection-pool</span> <span class="parameter">()</span>
</p>

<p class="desc">
　接続プールのすべての接続を切断して削除する。
</p>

<a name="*max-pool-size*"></a>
<p class="def">
<span class="deftype">変数</span>
<span class="variable">*max-pool-size*</span>
</p>

<p class="desc">
　<span class="e3">単一の</span>接続プールで保持される接続の最大数を設定。プールは全て、完全に同じ引数での接続で構成される。デフォルトは <code>NIL</code> で、最大値なしである。
</p>

<a name="querying"></a>
<h2>クエリ</h2>

<a name="query"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">query</span> <span class="parameter">(query &amp;rest args/format)</span><br />
&#8594; result
</p>

<p class="desc">
　指定された <code class="parameter">query</code> を実行する。 <code class="parameter">query</code> は文字列または <a href="s-sql_jp.html">S-SQL</a> 形式（キーワードで始まるリスト）である。クエリにプレースホルダ（ <code>$1</code> 、 <code>$2</code> など）が含まれている場合、その値は引数として与えられる。これらの引数の 1 つが下の表に現れるキーワードの場合、 <code class="parameter">query</code> 引数としては使用されず、代わりに結果が返される <code class="parameter">format</code> が決定される。次の形式のいずれかが使用され、デフォルトは <code class="keyword">:rows</code> である。
</p>

<table class="desc">
<tr>
<td><code class="keyword">:none</code></td>
<td>結果の値を無視する。</td>
</tr>
<tr>
<td><code class="keyword">:lists</code>, <code class="keyword">:rows</code></td>
<td>行の値を含んだリストのリストを返す。</td>
</tr>
<tr>
<td><code class="keyword">:list</code>, <code class="keyword">:row</code></td>
<td>単一行をリストとして返す。</td>
</tr>
<tr>
<td><code class="keyword">:alists</code></td>
<td>列名を値にマップする連想リスト（ a-list ）のリストを返す。列名はキーワードで表される。</td>
</tr>
<tr>
<td><code class="keyword">:alist</code></td>
<td>単一行を連想リストとして返す。</td>
</tr>
<tr>
<td><code class="keyword">:str-alists</code></td>
<td><code class="keyword">:alists</code> と似ているが、元の列名を使用。</td>
</tr>
<tr>
<td><code class="keyword">:str-alist</code></td>
<td>単一行を連想リスト（ a-list ）として返す。名前には文字列を使用。</td>
</tr>
<tr>
<td><code class="keyword">:plists</code></td>
<td>列名を値にマップする p-list のリストを返す。列名はキーワードで表される。</td>
</tr>
<tr>
<td><code class="keyword">:plist</code></td>
<td>単一の行を p-list として返す。</td>
</tr>
<tr>
<td><code class="keyword">:column</code></td>
<td>単一の列をリストとして返す。</td>
</tr>
<tr>
<td><code class="keyword">:single</code></td>
<td>単一の値を返す。</td>
</tr>
<tr>
<td><code class="keyword">:single!</code></td>
<td><code class="keyword">:single</code> と似ているが、選択された行数が 1 でない時、エラーを発生させる。</td>
</tr>
<tr>
<td><code>(<span class="keyword">:dao</span> type)</code></td>
<td>与えられた型の DAO のリストを返す。クエリによって返されるフィールド名は、 <a href="#query-dao"><code class="operator">query-dao</code></a> での場合と同様に、DAO クラスのスロットと一致する必要がある。</td>
</tr>
<tr>
<td><code>(<span class="keyword">:dao</span> type <span class="keyword">:single</span>)</code></td>
<td>与えられた型の単一の DAO を返す。</td>
</tr>
</table>

<p class="desc">
　データベースが、クエリの更新や削除などの影響を受けた行数の情報を返す場合、これは 2 番目の値で返される。<span class="e2">（※多値）</span>
</p>

<a name="execute"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">execute</span> <span class="parameter">(query &amp;rest args)</span>
</p>

<p class="desc">
　<code class="parameter">format</code> を <code class="keyword">:none</code> で呼び出した関数 <a href="#query"><code class="operator">query</code></a> に似ている。影響を受けた行数を最初の戻り値として返す。（ 2 番目の値としても返すが、その使用は非推奨）
</p>

<a name="doquery"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">doquery</span> <span class="parameter">(query (&amp;rest names) &amp;body body)</span>
</p>

<p class="desc">
　指定された <code class="parameter">query</code> （文字列またはキーワードで始まるリスト）を実行し、結果の行を反復処理する。 <code class="parameter">names</code> で与えられたシンボルは行の値で束縛され、 <code class="parameter">body</code> が実行される。パラメータ化されたクエリを繰り返し処理する為に、 <span class="e3">car</span> がクエリで <span class="e3">cdr</span> に引数が含まれているリストを指定できる。例えば：
</p>

<pre class="code">
(doquery (:select 'name 'score :from 'scores) (n s)
  (incf (gethash n *scores*) s))

(doquery ((:select 'name :from 'scores :where (:> 'score '$1)) 100) (name)
  (print name))
</pre>

<a name="prepare"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">prepare</span> <span class="parameter">(query &amp;optional (format :rows))</span><br />
&#8594; function
</p>

<p class="desc">
　プリペアドステートメントへのインターフェイスとして使用できる関数を作成する。指定された <code class="parameter">query</code> （文字列または <a href="s-sql_jp.html">S-SQL</a> フォーム）には、 <code>$1</code> 、 <code>$2</code> などのプレースホルダが含まれるかもしれない。結果の関数は、 <code class="parameter">query</code> の各プレースホルダに対して 1 つの引数をとり、準備されたクエリを実行して、指定された <code class="parameter">format</code> （ <span class="parameter">format</span> に許される値は関数 <a href="#query"><code>query</code></a> と同じ）で結果を返す。
</p>

<p class="desc">
　非常に頻繁に実行する必要のあるクエリの場合、特に複雑なクエリの場合には、一度だけサーバで計画すればよいので、パフォーマンスに貢献する可能性がある。詳細は、 <a href="http://www.postgresql.org/docs/current/static/sql-prepare.html">PostgreSQL マニュアル</a>参照。
</p>

<p class="desc">
　場合によっては、サーバがステートメント内の引数の型を推測できないと文句を言うだろう。その場合は、型宣言（ PostgreSQL の <code>CAST</code> SQL 準拠の構文または <code>::</code> 構文、あるいは S-SQL の <a href="s-sql_jp.html#type"><code>:type</code></a> 構文）を追加してすべきである。 
</p>

<a name="defprepared"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">defprepared</span> <span class="parameter">(name query &amp;optional (format :rows))</span>
</p>

<p class="desc">
　これはマクロ <a href="#prepare"><code class="operator">prepare</code></a> を <code class="operator">defun</code> スタイルにしたもの。プリペアドステートメントのトップレベル関数を定義する。
</p>

<a name="defprepared-with-names"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">defprepared-with-names</span> <span class="parameter">(name (&amp;rest args) (query &amp;rest query-args) &amp;optional (format :rows))</span>
</p>

<p class="desc">
　マクロ <a href="#defprepared"><code class="operator">defprepared</code></a> と似ているが、 <a href="#query"><code class="operator">query</code></a> に供給される引数のように関数に引数を許す。
</p>

<pre class="code">
(defprepared-with-names user-messages (user &amp;key (limit 10))
  ("select * from messages
    where user_id = $1
    order by date desc
    limit $2" (user-id user) limit)
  :plists)
</pre>

<a name="with-transaction"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">with-transaction</span> <span class="parameter">((&amp;optional name) &amp;body body)</span>
</p>

<p class="desc">
　データベーストランザクション内で与えられた <code class="parameter">body</code> を実行し、 <code class="parameter">body</code> が正常終了すればコミットし、それ以外の場合はアボートする。オプションの <code class="parameter">name</code> はトランザクションに与えられ、 <code class="parameter">body</code> が巻き戻される前に強制的なコミットまたはアボートに使用できる。
</p>

<a name="commit-transaction"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">commit-transaction</span> <span class="parameter">(transaction)</span>
</p>

<p class="desc">
　指定された <code class="parameter">transaction</code> をコミットする。
</p>

<a name="abort-transaction"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">abort-transaction</span> <span class="parameter">(transaction)</span>
</p>

<p class="desc">
　指定された <code class="parameter">transaction</code> をロールバックする。
</p>

<a name="with-savepoint"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">with-savepoint</span> <span class="parameter">(name &amp;body body)</span>
</p>

<p class="desc">
　トランザクション内でのみ使用できる。 <code class="parameter">body</code> 開始時与えられた <code class="parameter">name</code> でセーブポイントを設定し、 <code class="parameter">name</code> をセーブポイントのハンドルに束縛する。 <code class="parameter">body</code> 終了時コンディションがスローされない限り、セーブポイントが解放される。コンディションがスローされた場合ロールバックされる。

</p>

<a name="release-savepoint"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">release-savepoint</span> <span class="parameter">(savepoint)</span>
</p>

<p class="desc">
　指定された <code class="parameter">savepoint</code> を解放する。
</p>

<a name="rollback-savepoint"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">rollback-savepoint</span> <span class="parameter">(savepoint)</span>
</p>

<p class="desc">
　指定された <code class="parameter">savepoint</code> をロールバックする。
</p>

<a name="commit-hooks"></a>
<p class="def">
<span class="deftype">アクセサ</span>
<span class="operator">commit-hooks</span> <span class="parameter">(transaction-or-savepoint)</span>,
<span class="operator">setf</span> <span class="parameter">(commit-hooks transaction-or-savepoint)</span>
</p>

<p class="desc">
　トランザクションまたはセーブポイントのコミット・フックとなるリストへのアクセサ。それぞれが必須引数を持たない関数でなければならない。これらの関数は、トランザクションがコミットされるか、セーブポイントが解放される時に実行される。
</p>

<a name="abort-hooks"></a>
<p class="def">
<span class="deftype">アクセサ</span>
<span class="operator">abort-hooks</span> <span class="parameter">(transaction-or-savepoint)</span>,
<span class="operator">setf</span> <span class="parameter">(abort-hooks transaction-or-savepoint)</span>
</p>

<p class="desc">
　トランザクションまたはセーブポイントのアボート・フックとなるリストへのアクセサ。それぞれが必須引数を持たない関数でなければならない。これらの関数は、トランザクションがアボートされるか、セーブポイントがロールバックされる時に実行される。（ローカルでないコントロールの転送、あるいは関数 <a href="#abort-transaction"><code class="operator">abort-transaction</code></a> または関数 <a href="#rollback-savepoint"><code class="operator">rollback-savepoint</code></a> による明示的なもの）
</p>

<a name="with-logical-transaction"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">with-logical-transaction</span> <span class="parameter">((&amp;optional name) &amp;body body)</span>
</p>

<p class="desc">
　現在進行中のトランザクションがない場合は、マクロ <a href="#with-transaction"><code class="operator">with-transaction</code></a> フォーム内で <code class="parameter">body</code> を実行し、そうでない場合は、マクロ <a href="#with-savepoint"><code class="operator">with-savepoint</code></a> フォームで実行してトランザクションをシミュレートする。 <code class="parameter">name</code> が指定された場合は、トランザクションまたはセーブポイントに束縛される。
</p>

<a name="abort-logical-transaction"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">abort-logical-transaction</span> <span class="parameter">(transaction-or-savepoint)</span>
</p>

<p class="desc">
　実際のトランザクションかセーブポイントであるかに関わらず、指定された論理トランザクションをロールバックする。
</p>

<p class="def">
<span class="deftype">関数</span>
<a name="commit-logical-transaction"></a>
<span class="operator">commit-logical-transaction</span> <span class="parameter">(transaction-or-savepoint)</span>
</p>

<p class="desc">
　実際のトランザクションかセーブポイントであるかに関わらず、指定された論理トランザクションをコミットする。
</p>

<p class="def">
<a name="*current-logical-transaction*"></a>
<span class="deftype">変数</span>
<span class="variable">*current-logical-transaction*</span>
</p>

<p class="desc">
　これは最も内側のオープン論理トランザクションを表す、現在の <code>transaction-handle</code> または <code>savepoint-handle</code> インスタンスに束縛される。
</p>


<p class="def">
<span class="deftype">マクロ</span>
<a name="ensure-transaction"></a>
<span class="operator">ensure-transaction</span> <span class="parameter">(&amp;body body)</span>
</p>

<p class="desc">
　<code class="parameter">body</code> がトランザクション内で実行されるよう保証するが、すでに進行中のトランザクションがある場合は新たなトランザクションを開始しない。
</p>

<a name="with-schema"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">with-schema</span> <span class="parameter">((namespace &amp;key :strict t :if-not-exist :create :drop-after) &amp;body body)</span>
</p>

<p class="desc">
　現在のスキーマを <code class="parameter">namespace</code> にセットし、 <code class="parameter">body</code> を実行する。 <code class="parameter">body</code> 実行前に、 PostgreSQL のセッション変数 <code>search_path</code> は指定された <code class="parameter">namespace</code> に設定される。 <code class="parameter">body</code> 実行後、変数 <code>search_path</code> は元の値に復元される。キーワード <code class="keyword">:strict</code> が <code>T</code> にセットされている場合、 <code class="parameter">namespace</code> は <code class="parameter">body</code> 実行時の検索パス上のスキームに過ぎない。それ以外の場合、 <code class="parameter">namespace</code> は <code class="parameter">body</code> 実行時の検索パス上の最初のスキーマに過ぎない。もし <code class="keyword">:if-not-exist</code> が <code>NIL</code> の場合、エラーが通知される。 もし <code class="keyword">:drop-after</code> が <code>T</code> の場合、 <code class="parameter">body</code> 実行後に <code class="parameter">namespace</code> がデータベースから削除される。
</p>

<a name="sequence-next"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">sequence-next</span> <span class="parameter">(sequence)</span><br />
&#8594; integer
</p>

<p class="desc">
　<code class="parameter">sequence</code> から次の値を取得する。シーケンス識別子は文字列またはシンボルのいずれかで、後者の場合、 <a href="s-sql_jp.html">S-SQL</a> の規則に従って文字列に変換される。
</p>

<p class="def">
<span class="deftype">関数</span>
<a name="coalesce"></a>
<span class="operator">coalesce</span> <span class="parameter">(&amp;rest arguments)</span><br />
&#8594; value
</p>

<p class="desc">
　最初の非 <code>NIL</code> あるいは非 NULL（ <code>:null</code> ）の引数を返す。何もない場合は <code>NIL</code> 返す。クエリの結果にフォールバック値を提供する場合、あるいは 1 つの引数のみが与えられた場合、 <code>:null</code> を <code>NIL</code> に変換するのに有用である。
</p>

<a name="inspect"></a>
<h2>データベースの検査</h2>

<a name="list-tables"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">list-tables</span> <span class="parameter">(&amp;optional strings-p)</span><br />
&#8594; list
</p>

<p class="desc">
　現在のデータベース内のテーブルのリストを返す。 <code class="parameter">strings-p</code> が <code>T</code> 場合、名前は文字列として与えられる。それ以外の場合、キーワードとして与えられる。
</p>

<a name="table-exists-p"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">table-exists-p</span> <span class="parameter">(name)</span><br />
&#8594; boolean
</p>

<p class="desc">
　<code class="parameter">name</code> で指定されたテーブルが存在するかどうかをテストする。 <code class="parameter">name</code> は文字列またはシンボル。
</p>

<a name="table-description"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">table-description</span> <span class="parameter">(name &amp;optional schema-name)</span><br />
&#8594; list
</p>

<p class="desc">
　名前付きテーブルのフィールドのリストを返す。各フィールドは 3 要素のリストで表される：フィールド名、型、フィールドが NULL を許すかどうかを示す真偽値。オプションで、 <code class="parameter">schema-name</code> を指定して、結果を名前付きスキーマのフィールドに制限できる。それがなければ、スキーマに関係なく、テーブルの全フィールドが返される。
</p>

<a name="list-sequences"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">list-sequences</span> <span class="parameter">(&amp;optional strings-p)</span><br />
&#8594; list
</p>

<p class="desc">
　現在のデータベース内のシーケンスのリストを返す。 <code class="parameter">strings-p</code> が <code>T</code> の場合、名前は文字列として与えられ、それ以外の場合はキーワードとして与えられる。
</p>

<a name="sequence-exists-p"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">sequence-exists-p</span> <span class="parameter">(name)</span><br />
&#8594; boolean
</p>

<p class="desc">
　<code class="parameter">name</code> で指定されたシーケンスが存在するかどうかをテストする。 <code class="parameter">name</code> は文字列またはシンボル。
</p>

<a name="list-views"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">list-views</span> <span class="parameter">(&amp;optional strings-p)</span><br />
&#8594; list
</p>

<p class="desc">
　現在のデータベース内のユーザー定義ビューのリストを返す。 <code class="parameter">strings-p</code> が <code>T</code> の場合、名前は文字列として返し、それ以外の場合はキーワードとして返す。
</p>

<a name="view-exists-p"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">view-exists-p</span> <span class="parameter">(name)</span><br />
&#8594; boolean
</p>

<p class="desc">
　<code class="parameter">name</code> で指定されたビューが存在するかどうかをテストする。 <code class="parameter">name</code> は文字列またはシンボル。
</p>

<a name="list-schemata"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">list-schemata</span> <span class="parameter">()</span><br />
&#8594; list
</p>

<p class="desc">
　ユーザ定義のスキーマのリスト（文字列として）と既存のスキーマ数を返す。
</p>

<a name="schema-exist-p"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">schema-exist-p</span> <span class="parameter">(schema)</span><br />
&#8594; boolean
</p>

<p class="desc">
　<code class="parameter">schema</code> で指定された存在をテストする。スキーマが存在する場合は <code>T</code> 返し、それ以外の場合は <code>NIL</code> を返す。
</p>

<a name="daos"></a>
<h2>データベースアクセスオブジェクト</h2>

<p>
　Postmodern には、データベースの行を表した CLOS クラスを定義するシンプルなシステムが含まれる。これは本格的なオブジェクトリレーショナルマジックシステムを意図したものではない。本格的なオブジェクトリレーショナルマジックシステムが果たす役割もあるが、それらは正当な権利を得るのが難しく、このような謙虚な SQL ライブラリの範疇外である。
</p>

<a name="dao-class"></a>
<p class="def">
<span class="deftype">メタクラス</span>
<span class="type">dao-class</span>
</p>

<p class="desc">
　Postmodern の DAO システムの中心には、 <code class="type">dao-class</code> メタクラスがある。これにより独自のデータベースアクセス用のクラスを通常の CLOS クラスとして定義できる。クラスのスロットのいくつかは、データベースの列を参照する。列を参照するスロットを指定するには、 <a href="s-sql_jp.html">S-SQL</a> 型式に <code class="keyword">:col-type</code> オプションを与える（クラス定義からテーブル定義を派生させたい場合に便利）か、あるいは単に <code class="keyword">:column</code> オプションの値を <code>T</code> にする。そのようなスロットは、データベース側のデフォルト値を S-SQL 式として提供するのに使用される <code class="keyword">:col-default</code> オプションを使用することもできる。 <code class="keyword">:col-name</code> initarg （評価されていない値が関数 <a href="s-sql_jp.html#to-sql-name"><code class="operator">to-sql-name</code></a> に渡される）を使用して、スロットの列名を指定することができる。
</p>

<p class="desc">
  DAO クラスの定義は 2 つの特別なクラスオプションをサポートする。： <code class="keyword">:table-name</code> はクラスが参照するをテーブル名を与える。（デフォルトはクラス名）　そして <code class="keyword">:keys</code> はテーブルの主キーを提供する。主キーが定義されていない場合、メソッド <a href="#update-dao"><code>update-dao</code></a> やメソッド <a href="#get-dao"><code>get-dao</code></a> などの操作は機能しない。
</p>

<p class="desc">
　簡単な例：
</p>

<pre class="code">
(defclass user ()
  ((name :col-type string :initarg :name :accessor user-name)
   (creditcard :col-type (or db-null integer) :initarg :card :col-default :null)
   (score :col-type bigint :col-default 0 :accessor user-score))
  (:metaclass dao-class)
  (:keys name))
</pre>

<p class="desc">
　フォーム <code>(or db-null integer)</code> は、列が NULL 値を許すことを示すのに使用される。
</p>

<p class="desc">
　DAO クラスを継承する場合、派生クラスの列セットには親クラスの全ての列も含まれる。そのようなクラスの主キーは、そのクラス自身でのキーと親クラスからの全てのキーの和である。 DAO クラスを継承するクラスはおそらく常にメタクラス <code class="type">dao-class</code> を使用するべきである。
</p>

<p class="desc">
　メソッド <code class="operator">make-instance</code> で DAO を作成すると、 <code class="keyword">:fetch-defaults</code> キーワード引数を渡すことができ、 <code>T</code> を指定した時、列を参照する全スロットのデフォルト値をフェッチして、 initarg で束縛されない。暗黙的なデフォルトを持つ <code>serial</code> 列などいくつかの場合は、これは機能しない。これを回避するには、 <code class="string">"my_sequence"</code> などの独自シーケンスを作成し、 <code>(<span class="keyword">:nextval</span> <span class="string">"my_sequence"</span>)</code> デフォルトを定義する。
</p>

<p class="desc">
　最後に、DAO クラスのスロットにはゴーストスロットを指定する <code><span class="keyword">:ghost</span> t</code> オプションがある。これらはインスタンス取得時に選択されるが、アップデートまたはインサート時には書き込まれず、テーブル定義に含まれることもない。これまでに唯一知られているのは、テーブル作成時の日付での <code>(oids=true)</code> で、次のようにスロットを指定する： 
</p>

<pre class="code">
(oid :col-type integer :ghost t :accessor get-oid)
</pre>

<a name="dao-keys"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">dao-keys</span> <span class="parameter">(class)</span><br />
&#8594; list
</p>

<p class="desc">
　DAO <code class="parameter">class</code> 主キーのスロット名リストを返す。
</p>

<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">dao-keys</span> <span class="parameter">(dao)</span><br />
&#8594; list
</p>

<p class="desc">
　<code class="parameter">dao</code> の主キー値のリストを返す。
</p>

<a name="dao-exists-p"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">dao-exists-p</span> <span class="parameter">(dao)</span><br />
&#8594; boolean
</p>

<p class="desc">
　指定された <code class="parameter">dao</code> と同じ主キーを持つ行がデータベースに存在するかどうかをテストする。オブジェクトのキーのスロットのいずれかが未束縛の場合にも <code>NIL</code> を返す。
</p>

<a name="make-dao"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">make-dao</span> <span class="parameter">(type &amp;rest args &amp;key &amp;allow-other-keys)</span><br />
&#8594; dao
</p>

<p class="desc">
　メソッド <code class="operator">make-instance</code> とメソッド <a href="#insert-dao"><code class="operator">insert-dao</code></a> の複合。作成された dao を返す。
</p>

<a name="define-dao-finalization"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">define-dao-finalization</span> <span class="parameter">(((dao-name class) &amp;rest keyword-args) &amp;body body)</span>
</p>

<p class="desc">
　メソッド <a href="#make-dao"><code class="operator">make-dao</code></a> の <code class="keyword">:around</code> メソッドを作成する。 <code class="parameter">dao-name</code> が新しく作成されインサートされた DAO に束縛されたレキシカル環境で、 <code class="parameter">body</code> が実行される。データベース内の DAO の表現は、 <code class="parameter">body</code> が招いた変更を反映するよう更新される。メソッド <a href="#insert-dao"><code class="operator">insert-dao</code></a> 前には未知である <code>serial</code> 型スロットの値を処理するのに有用である。
</p>

<a name="get-dao"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">get-dao</span> <span class="parameter">(type &amp;rest keys)</span><br />
&#8594; dao
</p>

<p class="desc">
　指定の主キー値を持つ行から DAO オブジェクトを選択するか、そのような行が存在しない場合は <code>NIL</code> 選択する。この関数で作成されたオブジェクトは関数 <code class="operator">initialize-instance</code> が引数なしで呼ばれる。（データベースから値をロードした後）。クラスオプション <code class="keyword">:default-initargs</code> もスキップされる。マクロ <a href="#select-dao"><code class="operator">select-dao</code></a> と関数 <a href="#query-dao"><code class="operator">query-dao</code></a> も同様。
</p>

<a name="select-dao"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">select-dao</span> <span class="parameter">(type &amp;optional (test t) &amp;rest sort)</span><br />
&#8594; list
</p>

<p class="desc">
　指定された <code class="parameter">test</code> （ <a href="s-sql_jp.html">S-SQL</a> 式または文字列）で決定する関連テーブル行の DAO オブジェクトを選択する。ソート引数（ S-SQL フォームでも文字列でもよい）が指定されている場合、結果をソートするために使用される。（ソートしたい場合、引数 <code class="parameter">test</code> を渡す<span class="e3">必要</span>があることに注意）
</p>

<pre class="code">
(select-dao 'user (:> 'score 10000) 'name)
</pre>

<a name="do-select-dao"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">do-select-dao</span> <span class="parameter">(((type type-var) &amp;optional (test t) &amp;rest sort) &amp;body body)</span>
</p>

<p class="desc">
　マクロ <a href="#select-dao"><code class="operator">select-dao</code></a> に似ているが、結果を返すのではなく繰り返し処理を行う。一致する DAO ごとに、 <code class="parameter">type-var</code> が DAO インスタンスに束縛されて <code class="parameter">body</code> が評価される。
</p>

<pre class="code">
(do-select-dao (('user user) (:> 'score 10000) 'name)
  (pushnew user high-scorers))
</pre>

<a name="query-dao"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">query-dao</span> <span class="parameter">(type query &amp;rest args)</span><br />
&#8594; list
</p>

<p class="desc">
　指定された <code class="parameter">query</code> （文字列または <a href="s-sql_jp.html">S-SQL</a> 式のいずれか）を実行し、その結果を指定された <code class="parameter">type</code> の DAO として返す。 <code class="parameter">query</code> がプレースホルダ（ $1 、 $2 など）を含む場合、その値は引数として指定できる。 <code class="parameter">query</code> によって返されるフィールド名は、 DAO クラスのスロットと一致するか、マクロ <a href="#with-column-writers"><code class="operator">with-column-writers</code></a> を介して束縛される必要がある。
</p>

<a name="do-query-dao"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">do-query-dao</span> <span class="parameter">(((type type-var) query &amp;rest args) &body body)</span><br />
&#8594; list
</p>

<p class="desc">
　<a href="#query-dao"><code class="operator">query-dao</code></a> と似ているが、結果を返すのではなく、結果を繰り返し処理する。一致する DAO ごとに、 <code class="parameter">body</code> は、インスタンスに束縛された <code class="parameter">type-var</code> を伴い評価される。
</p>

<pre class="code">
(do-query-dao (('user user) (:order-by (:select '* :from 'user :where (:> 'score 10000)) 'name))
  (pushnew user high-scorers))
</pre>

<a name="*ignore-unknown-columns*"></a>
<p class="def">
<span class="deftype">変数</span>
<span class="variable">*ignore-unknown-columns*</span>
</p>

<p class="desc">
　通常、メソッド <a href="#get-dao"><code class="operator">get-dao</code></a> 、マクロ <a href="#select-dao"><code class="operator">select-dao</code></a> 、または関数 <a href="#query-dao"><code class="operator">query-dao</code></a> がデータベース内で DAO クラスにない列を見つけると、エラーを発生させる。この変数を非 <code>NIL</code> に設定すると、単に未知の列を無視する。
</p>

<a name="insert-dao"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">insert-dao</span> <span class="parameter">(dao)</span><br />
&#8594; dao
</p>

<p class="desc">
　指定された <code class="parameter">dao</code> をデータベースにインサートする。オブジェクトの未束縛の列スロットは、データベースのデフォルトを意味する。したがって、これらの列にデータベースで定義されているデフォルトがない場合、 <code class="parameter">dao</code> のインサートは失敗する。（この機能は PostgreSQL 8.2以降でのみ動作）
</p>

<a name="update-dao"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">update-dao</span> <span class="parameter">(dao)</span><br />
&#8594; dao
</p>

<p class="desc">
　データベース内で指定された <code class="parameter">dao</code> 表現をオブジェクトの値に更新する。これは主キー以外の列を持たない表に対しては定義されない。 <code class="parameter">dao</code> に一致する行が存在しない場合、エラーを発生させる。
</p>

<a name="save-dao"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">save-dao</span> <span class="parameter">(dao)</span><br />
&#8594; boolean
</p>

<p class="desc">
　メソッド <a href="#insert-dao"><code class="operator">insert-dao</code></a> を使用して、指定された <code class="parameter">dao</code> のインサートを試みる。キー一意違反エラーが発生すれば、代わりにメソッド <a href="#update-dao"><code class="operator">update-dao</code></a> を使用してアップデートを試みる。ここで競合状態が発生する可能性があることに注意。もし他のプロセスが絶妙なタイミングで行を削除すると、アップデートに失敗する。新しい行がインサートされたかどうかを示す真偽値を返す。
</p>

<p class="desc">
　この関数は、トランザクション内部での使用は安全ではない。指定されたキーを持つ行がすでに存在する場合、トランザクションはアボートされる。そのような状況では、代わりに関数 <a href="#save-dao/transaction"><code class="operator">save-dao/transaction</code></a> を使用する。
</p>

<p class="desc">
<span class="e3">参照：</span> メソッド <a href="#upsert-dao"><code class="operator">upsert-dao</code></a>
</p>

<a name="save-dao/transaction"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">save-dao/transaction</span> <span class="parameter">(dao)</span><br />
&#8594; boolean
</p>

<p class="desc">
　関数 <a href="#save-dao"><code class="operator">save-dao</code></a> と全く同じように動作するが、オブジェクトのインサートの試みをロールバックポイントで保護し、障害がトランザクションをアボートしないようになっている。
</p>

<p class="desc">
<span class="e3">参照：</span> メソッド <a href="#upsert-dao"><code class="operator">upsert-dao</code></a>
</p>

<a name="upsert-dao"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">upsert-dao</span> <span class="parameter">(dao)</span><br />
&#8594; dao
</p>

<p class="desc">
　関数 <a href="#save-dao"><code class="operator">save-dao</code></a> や関数 <a href="#save-dao/transaction"><code class="operator">save-dao/transaction</code></a> に似ているが、データベース例外と関与しない異なるメソッドを使用する。これは競合状態を防ぐために常にトランザクション内で行うことを勧めるが、トランザクションの内外どちらでも安全に使用できる。それが機能する方法は：
</p>

<ol class="desc">
<li>オブジェクトが未束縛スロットを含んでいる場合、直接メソッド <a href="#insert-dao"><code class="operator">insert-dao</code></a> を呼び出す。従って挙動は関数 <a href="#save-dao"><code class="operator">save-dao</code></a> 同様になる。</li>
<li>それ以外の場合、同じ主キーでのレコードアップデートを試みる。 PostgreSQL がアップデートされた行数としてゼロでない値を返した場合、レコードがデータベースにすでに存在しているものと<span class="e3">扱い</span>、ここで処理を停止する。</li>
<li>PostgreSQL がアップデートされた行数にゼロを返した場合、レコードが存在しないものと<span class="e3">扱い</span>、メソッド <a href="#insert-dao"><code class="operator">insert-dao</code></a> を呼び出す。</li>
</ol>

<p class="desc">
　競合状態は、<span class="e3">トランザクションがない場合に</span>第 3 ステップで発生する可能性がある。： UPDATE がアップデートされた行数にゼロを返し、別のスレッドがその時点でレコードをインサートすれば、第 3 ステップで示された挿入は失敗する。
</p>

<p class="desc">
　トリガとルールが、 PostgreSQL によって返されたインサートまたはアップデートされた行数に影響を与える可能性があるため、影響を受けた行数がゼロにしろゼロでないにしろ、<span class="e3">実際に</span>データベースに存在するレコード数を示さない可能性がある。
</p>

<p class="desc">
　このメソッドは 2 つの値を返す。 DAO オブジェクトと真偽値である。（オブジェクトがインサートされた場合は <code>T</code> 、アップデートされた場合は <code>NIL</code>  ）。 
</p>

<a name="delete-dao"></a>
<p class="def">
<span class="deftype">メソッド</span>
<span class="operator">delete-dao</span> <span class="parameter">(dao)</span>
</p>

<p class="desc">
　指定された <code class="parameter">dao</code> をデータベースから削除する。
</p>

<a name="dao-table-name"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">dao-table-name</span> <span class="parameter">(class)</span><br />
&#8594; string
</p>

<p class="desc">
　指定された DAO <code class="parameter">class</code>（またはそのようなクラスを名付けたシンボル）に関連付けられたテーブル名を取得する。
</p>

<a name="dao-table-definition"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">dao-table-definition</span> <span class="parameter">(class)</span><br />
&#8594; string
</p>

<p class="desc">
　DAO <code class="parameter">class</code> またはその名前を指定すれば、テーブル定義を含む SQL クエリ文字列を生成する。これは簡単な定義なので、特別にインデックスや制約が必要な場合は、それらを追加するクエリを独自に作成する必要がある。
</p>

<a name="with-column-writers"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">with-column-writers</span> <span class="parameter">((&amp;rest writers) &amp;body body)</span>
</p>

<p class="desc">
　メソッド <a href="#get-dao"><code class="operator">get-dao</code></a> 、マクロ <a href="#select-dao"><code class="operator">select-dao</code></a> 、および関数 <a href="#query-dao"><code class="operator">query-dao</code></a> を使い、データベースから値を読み取る。これは一般には必要ではないが、システムが作成するクエリ量を減らすのに使用できる。 <code class="parameter">writers</code> は列名（文字列またはシンボル）とライタを交互にしたリストでなければならない。ライタはオブジェクト内のスロットを示すシンボルか、あるいは新しいインスタンスへの値格納に用いられるインスタンスと値の 2 つの引数を取る関数である。 DAO フェッチ関数が <code class="parameter">body</code> で呼び出され、結果から指定された名前に一致する列が見つかれば、デフォルト動作（列名に一致するスロットに値を格納する）の代わりにライタが使用される。
</p>

<p class="desc">
　これを使用する例は、列スロットでないスロットを DAO クラスに追加し、マクロ <code class="operator">with-column-writers</code> フォーム内で関数 <a href="#query-dao"><code class="operator">query-dao</code></a> を使用して、オブジェクトに関する追加情報を取得し、直ちに新しいインスタンスに格納するものである。
</p>

<a name="tabledef"></a>
<h2>テーブル定義と作成</h2>

<p>
　データベースの自動デプロイメントなどの目的で、ソースコードからアプリケーションのテーブルを構築する為に必要な SQL 文を取得することは有用である。次のマクロと関数は、シンボルで SQL 文のセットのグループ化を可能にする。また、テーブル定義の共通要素のショートカットもある。
</p>

<a name="deftable"></a>
<p class="def">
<span class="deftype">マクロ</span>
<span class="operator">deftable</span> <span class="parameter">(name &amp;body definition)</span>
</p>

<p class="desc">
　テーブルを定義する。 <code class="parameter">name</code> はシンボルまたは <code>(symbol string)</code> リストである。最初のケースでは、テーブル名は <a href="s-sql_jp.html">S-SQL</a> のルールによってシンボル名から導出される。 2 番目のケースでは、 <code class="parameter">name</code> は明示的に与えられる。定義の本体には、 S-SQL 式だけでなく、文字列に評価されるものを含めることができる。変数 <a href="#*table-name*"><code class="variable">*table-name*</code></a> と <a href="#*table-name*"><code class="variable">*table-symbol*</code></a> は、本体と関連する値に束縛される。 <code class="parameter">definition</code> の評価は順序付けされているので、一般的にはまずテーブルを作成し、それからインデックスを定義することになる。
</p>

<a name="!dao-def"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">!dao-def</span> <span class="parameter">()</span>
</p>

<p class="desc">
　マクロ <a href="#deftable"><code class="operator">deftable</code></a> の本体で使用しなければならない。 <a href="#*table-symbol*"><code class="variable">*table-symbol*</code></a> を引数にして関数 <a href="#dao-table-definition"><code class="operator">dao-table-definition</code></a> を呼び出した結果を、 <code class="parameter">definition</code> （※マクロ <a href="#deftable"><code class="operator">deftable</code></a> の本体）に追加する。
</p>

<a name="!index"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">!index</span> <span class="parameter">(&amp;rest columns), <span class="operator">!unique-index</span> (&amp;rest columns)</span>
</p>

<p class="desc">
　定義されているテーブル上にインデックスを定義する。 <code class="parameter">columns</code> にはシンボルまたは文字列を指定できる。
</p>

<a name="!foreign"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">!foreign</span> <span class="parameter">(target-table columns &amp;optional target-columns &amp;key on-delete on-update deferrable initially-deferred)</span>
</p>

<p class="desc">
　定義されているテーブルに外部キーを追加する。 <code class="parameter">target-table</code> は参照先のテーブルである。 <code class="parameter">columns</code> は、<span class="e3">この</span>テーブルの列名のリストまたは単一名であり、参照されるテーブルの列名と異なる場合、 <code class="parameter">target-columns</code> は別の <code class="parameter">target-table</code> の列名のリストまたは単一列名である必要がある。 <code class="keyword">:primary-key</code> は <code class="parameter">target-table</code> の主キーの列を参照列として表す。
</p>

<p class="desc">
　引数 <code class="parameter">on-delete</code> および引数 <code class="parameter">on-update</code> は、（ S-SQL の） <a href="s-sql_jp.html#create-table"><code class="operator">create-table</code></a> で許可されているキーワードに従って、 ON DELETE および ON UPDATE アクションの指定に使用できる。さらに、引数 <code class="parameter">deferrable</code> と引数 <code class="parameter">initially-deferred</code> は、現在のトランザクション完了まで制約チェックを延期できるかどうか、およびこれがデフォルトで実行されるべきかどうかの指示に使用できる。これらがどれも実際には <code>&amp;key</code> 引数ではなく、実行時に <code>&amp;rest</code> 引数から選択されるので、 <code class="parameter">target-columns</code> が指定されなくても指定できる点に注意。<span class="e2">（※）</span> 
</p>

<p class="desc e2">
　※実際のコードでは、ラムダリストは次の様になっている。<br />
　<code class="parameter">(TARGET FIELDS &amp;REST TARGET-FIELDS/ON-DELETE/ON-UPDATE/DEFERRABLE/INITIALLY-DEFERRED)</code>
</p>

<a name="!unique"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">!unique</span> <span class="parameter">(target-fields &amp;key deferrable initially-deferred)</span>
</p>

<p class="desc">
　一意となる値（の組み合わせ）のみを含むように、1つまたは複数の列を制約する。引数 <code class="parameter">deferrable</code> および引数 <code class="parameter">initially-deferred</code> は関数 <a href="#!foreign"><code class="operator">!foreign</code></a> と同様。
</p>

<a name="create-table"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">create-table</span> <span class="parameter">(symbol)</span>
</p>

<p class="desc">
　<code class="parameter">symbol</code> で識別されるテーブルを、定義の全てのフォームを実行（マクロ <a href="#execute"><code class="operator">execute</code></a> ）して作成する。
</p>

<a name="create-all-tables"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">create-all-tables</span> <span class="parameter">()</span>
</p>

<p class="desc">
　定義された全てのテーブルを作成する。
</p>

<a name="create-package-tables"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">create-package-tables</span> <span class="parameter">(package)</span>
</p>

<p class="desc">
　指定された <code class="parameter">package</code> にインターンされているシンボルで識別される全てのテーブルを作成する。
</p>

<a name="*table-name*"></a><a name="*table-symbol*"></a>
<p class="def">
<span class="deftype">変数</span>
<span class="variable">*table-name*</span>, <span class="variable">*table-symbol*</span>
</p>

<p class="desc">
　これらの変数は、テーブル定義のフォームが評価されている間、関連する名前とシンボルに束縛される。以下のような短縮形を定義するのに使うことができる。
</p>

<a name="schemata"></a>
<h2>スキーマ</h2>

　スキーマはテーブルを異なる名前空間に分けることを可能にする。異なるスキーマでは、同じ名前で 2 つのテーブルが存在することが許される。テーブルは完全修飾名またはマクロ <a href="#with-schema"><code class="operator">with-schema</code></a> で参照できる。関数 <a href="#set-search-path"><code class="operator">set-search-path</code></a> を使用して検索パスを設定することもできる。列挙と存在チェックの為に、関数 <a href="#list-schemata"><code class="operator">list-schemata</code></a> と関数 <a href="#schema-exist-p"><code class="operator">schema-exist-p</code></a> がある。次の関数で、スキーマの作成、削除、および検索パスの設定ができる。

<a name="create-schema"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">create-schema</span> <span class="parameter">(schema)</span>
</p>

<p class="desc">
　新しいスキーマを作成する。スキーマがすでに存在する場合はエラーが発生する。
</p>

<a name="drop-schema"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">drop-schema</span> <span class="parameter">(schema)</span>
</p>

<p class="desc">
　スキーマを削除する。 スキーマが空でない場合はエラーが発生する。
</p>

<a name="get-search-path"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">get-search-path</span> <span class="parameter">()</span>
</p>

<p class="desc">
　現在の検索パスを取得する。
</p>

<a name="set-search-path"></a>
<p class="def">
<span class="deftype">関数</span>
<span class="operator">set-search-path</span> <span class="parameter">(path)</span>
</p>

<p class="desc">
　検索パスを <code class="parameter">path</code> に設定する。この関数はマクロ <a href="#with-schema"><code class="operator">with-schema</code></a> によって使用される。
</p>

<h2 id="index">シンボル索引</h2>

<ul class="symbol-index">
<li><a href="#abort-transaction"><span class="operator">abort-transaction</span></a></li>
<li><a href="#call-with-connection"><span class="operator">call-with-connection</span></a></li>
<li><a href="#clear-connection-pool"><span class="operator">clear-connection-pool</span></a></li>
<!-- <li><a href="#clear-template">clear-template</a></li> -->
<li><a href="#commit-transaction"><span class="operator">commit-transaction</span></a></li>
<li><a href="#connect"><span class="operator">connect</span></a></li>
<li><a href="#connect-toplevel"><span class="operator">connect-toplevel</span></a></li>
<li><a href="#connected-p"><span class="operator">connected-p</span></a></li>
<li><a href="#create-all-tables"><span class="operator">create-all-tables</span></a></li>
<li><a href="#create-package-tables"><span class="operator">create-package-tables</span></a></li>
<li><a href="#create-schema"><span class="operator">create-schema</span></a></li>
<li><a href="#create-table"><span class="operator">create-table</span></a></li>
<li><a href="#dao-class"><span class="type">dao-class</span></a></li>
<li><a href="#!dao-def"><span class="operator">!dao-def</span></a></li>
<li><a href="#dao-exists-p"><span class="operator">dao-exists-p</span></a></li>
<li><a href="#dao-keys"><span class="operator">dao-keys</span></a></li>
<li><a href="#dao-table-definition">dao-table-definition</a></li>
<li><a href="#dao-table-name"><span class="operator">dao-table-name</span></a></li>
<li><a href="#*database*"><span class="variable">*database*</span></a></li>
<li><a href="#database-connection"><span class="type">database-connection</span></a></li>
<!-- <li><a href="cl-postgres_jp.html#database-connection-lost">database-connection-lost</a></li> -->
<li><a href="cl-postgres_jp.html#database-error"><span class="type">database-error</span></a></li>
<li><a href="cl-postgres_jp.html#database-error-cause"><span class="operator">database-error-cause</span></a></li>
<li><a href="cl-postgres_jp.html#database-error-code"><span class="operator">database-error-code</span></a></li>
<li><a href="cl-postgres_jp.html#database-error-detail"><span class="operator">database-error-detail</span></a></li>
<li><a href="cl-postgres_jp.html#database-error-message"><span class="operator">database-error-message</span></a></li>
<li><a href="cl-postgres_jp.html#database-error-query"><span class="operator">database-error-query</span></a></li>
<li><a href="#*default-use-ssl*"><span class="variable">*default-use-ssl*</span></a></li>
<li><a href="#define-dao-finalization"><span class="operator">define-dao-finalization</span></a></li>
<li><a href="#defprepared"><span class="operator">defprepared</span></a></li>
<li><a href="#defprepared-with-names"><span class="operator">defprepared-with-names</span></a></li>
<li><a href="#deftable"><span class="operator">deftable</span></a></li>
<li><a href="#delete-dao"><span class="operator">delete-dao</span></a></li>
<li><a href="#disconnect"><span class="operator">disconnect</span></a></li>
<li><a href="#disconnect-toplevel"><span class="operator">disconnect-toplevel</span></a></li>
<li><a href="#doquery"><span class="operator">doquery</span></a></li>
<li><a href="#drop-schema"><span class="operator">drop-schema</span></a></li>
<li><a href="#execute"><span class="operator">execute</span></a></li>
<li><a href="#!foreign"><span class="operator">!foreign</span></a></li>
<li><a href="#get-dao"><span class="operator">get-dao</span></a></li>
<li><a href="#get-search-path"><span class="operator">get-search-path</span></a></li>
<li><a href="#*ignore-unknown-columns*"><span class="variable">*ignore-unknown-columns*</span></a></li>
<li><a href="#!index"><span class="operator">!index</span></a></li>
<li><a href="#insert-dao"><span class="operator">insert-dao</span></a></li>
<li><a href="#list-schemata"><span class="operator">list-schemata</span></a></li>
<li><a href="#list-sequences"><span class="operator">list-sequences</span></a></li>
<li><a href="#list-tables"><span class="operator">list-tables</span></a></li>
<li><a href="#list-views"><span class="operator">list-views</span></a></li>
<li><a href="#make-dao"><span class="operator">make-dao</span></a></li>
<li><a href="#*max-pool-size*"><span class="variable">*max-pool-size*</span></a></li>
<li><a href="#prepare"><span class="operator">prepare</span></a></li>
<li><a href="#query"><span class="operator">query</span></a></li>
<li><a href="#query-dao"><span class="operator">query-dao</span></a></li>
<li><a href="#reconnect"><span class="operator">reconnect</span></a></li>
<li><a href="#release-savepoint"><span class="operator">release-savepoint</span></a></li>
<!-- <li><a href="#reset-table">reset-table</a></li> -->
<li><a href="#rollback-savepoint"><span class="operator">rollback-savepoint</span></a></li>
<li><a href="#save-dao"><span class="operator">save-dao</span></a></li>
<li><a href="#save-dao/transaction"><span class="operator">save-dao/transaction</span></a></li>
<li><a href="#schema-exist-p"><span class="operator">schema-exist-p</span></a></li>
<li><a href="#select-dao"><span class="operator">select-dao</span></a></li>
<li><a href="#sequence-exists-p"><span class="operator">sequence-exists-p</span></a></li>
<li><a href="#sequence-next"><span class="operator">sequence-next</span></a></li>
<li><a href="#set-search-path"><span class="operator">set-search-path</span></a></li>
<li><a href="#table-description"><span class="operator">table-description</span></a></li>
<li><a href="#table-exists-p"><span class="operator">table-exists-p</span></a></li>
<li><a href="#*table-name*"><span class="variable">*table-name*</span></a></li>
<li><a href="#*table-symbol*"><span class="variable">*table-symbol*</span></a></li>
<li><a href="#!unique"><span class="operator">!unique</span></a></li>
<li><a href="#!index"><span class="operator">!unique-index</span></a></li>
<li><a href="#update-dao"><span class="operator">update-dao</span></a></li>
<li><a href="#view-exists-p"><span class="operator">view-exists-p</span></a></li>
<li><a href="#with-column-writers"><span class="operator">with-column-writers</span></a></li>
<li><a href="#with-connection"><span class="operator">with-connection</span></a></li>
<li><a href="#with-savepoint"><span class="operator">with-savepoint</span></a></li>
<li><a href="#with-schema"><span class="operator">with-schema</span></a></li>
<li><a href="#with-transaction"><span class="operator">with-transaction</span></a></li>
</ul>

</body>
</html>
